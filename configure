#! /usr/bin/env perl

use warnings;
use strict;
use Sort::strverscmp;

my $usage = <<EOF;
Usage: $0 [<option>[=<value>]...]
Generate configuration makefile for building LightNet.

options:
  -h, --help                     print help information
  --target=<name>                target name [lightnet]
  --abbr=<abbr>                  abbreviation name [ln]
  --build-dir=<path>             building directory [build]
  --install-dir=<path>           installation directory [/usr/local]
  --pkgconfig-dir=<path>         pkgconfig directory [/usr/local/lib/pkgconfig]
  --with-cuda=<bool>             set to yes if build with CUDA [no]
  --with-cudnn=<bool>            set to yes if build with cudnn library [no]
  --cuda-install-dir=<path>      cuda installation directory [/usr/local/cuda]
  --with-tensorrt=<bool>         set to yes if build with TensorRT [no]
  --tensorrt-install-dir=<path>  tensorrt installation directory [/usr]
  --debug=<bool>                 set to yes when debugging [no]
  --doc=<bool>                   set to yes if build the documents too [yes]
EOF

# default options, go in config.mk
my %opts = (
            "TARGET" => "lightnet",
            "ABBR" => "ln",
            "BUILD_DIR" => "build",
            "INSTALL_DIR" => "/usr/local",
            "PKGCONFIG_DIR" => "/usr/local/lib/pkgconfig",
            "WITH_CUDA" => "no",
            "WITH_CUDNN" => "no",
            "CUDA_INSTALL_DIR" => "/usr/local/cuda",
            "WITH_TENSORRT" => "no",
            "TENSORRT_INSTALL_DIR" => "/usr",
            "DEBUG" => "no",
            "DOC" => "yes",
           );

# parse arguments
while (@ARGV > 0) {
    my $arg = shift @ARGV;
    if ($arg eq "-h" or $arg eq "--help") {
        print $usage;
        exit;
    }
    if (not $arg =~ /^--(\S+)$/) {
        &err_exit("wrong format in argument \"$arg\"");
    }
    my ($opt, $value) = split /=/, $1;
    if (not defined $value or $value eq "") {
        &err_exit("option \"$arg\" doesn't have a value");
    }
    $opt =~ s/(\S+)/\U$1/gi;
    $opt =~ s/-/_/g;
    if (not exists $opts{$opt}) {
        &err_exit("invalid option \"$arg\"");
    }
    $opts{$opt} = $value;
}

# check configuration
# TODO: check versions
my $output;
$output = `gcc --version`;
if (!defined $output or $output eq "") {
    &err_exit("gcc not installed");
}

$output = `make --version`;;
if (!defined $output or $output eq "") {
    &err_exit("make not installed");
}

$output = `pkg-config --version`;;
if (!defined $output or $output eq "") {
    &err_exit("pkg-config not installed");
}

$output = `pkg-config --modversion check`;
if (!defined $output or $output eq "") {
    &err_exit("check not installed");
}

$output = `pkg-config --modversion tensorlight`;
if (!defined $output or $output eq "") {
    &err_exit("tensorlight not installed");
}

if ($opts{WITH_CUDNN} eq "yes") {
    if (not $opts{WITH_CUDA} eq "yes") {
        $opts{WITH_CUDA} = "yes";
        print ("automatically set --with-cuda=yes\n");
    }
}

if ($opts{WITH_TENSORRT} eq "yes") {
    if (not $opts{WITH_CUDA} eq "yes") {
        $opts{WITH_CUDA} = "yes";
        print ("automatically set --with-cuda=yes\n");
    }
}

if ($opts{WITH_CUDA} eq "yes") {
    $output = `nvcc --version`;;
    if (!defined $output or $output eq "") {
        &err_exit("nvcc not installed");
    }
}

if ($opts{DOC} eq "yes") {
    $output = `mkdocs --version`;;
    if (!defined $output or $output eq "") {
        &warn_msg("mkdocs is not installed; documents are not going to be built");
        $opts{DOC} = "no";
    } elsif (strverscmp(&mkdocs_version($output), "1.0.0") < 0) {
        my $version = &mkdocs_version($output);
        &warn_msg("mkdocs requires mininal version 1.0.0, but get $version; documents are not going to be built");
        $opts{DOC} = "no";
    }
}

# get current version
my $major = 0;
my $minor = 1;
my $micro = 0;
# my ($major, $minor, $micro);
# my $version_h = "src/tl_tensor.h";
# open my $version_h_fh, '<', $version_h or die "Cannot open $version_h: $!";
# while (<$version_h_fh>) {
#   $major = $1 if /MAJOR_VERSION \((\d)\)/;
#   $minor = $1 if /MINOR_VERSION \((\d)\)/;
#   $micro = $1 if /MICRO_VERSION \((\d)\)/;
# }
# close $version_h_fh;
# if (not defined $major or not defined $minor or not defined $micro) {
#   &err_exit("cannot find version macros in $version_h, maybe a bug?");
# }

# print configuration
my $config_str = <<EOF;
.SUFFIXES:
MAJOR = $major
MINOR = $minor
MICRO = $micro
EOF
foreach my $key (sort keys %opts) {
    $config_str .= "$key ?= $opts{$key}\n";
    print "$key = $opts{$key}\n";
}
my $conf_file = "config.mk";
open my $conf_fh, '>', $conf_file or die "Cannot open $conf_file: $!";
print $conf_fh $config_str;
close $conf_fh;

sub mkdocs_version {
    my $str = shift;
    my $version = "";
    $version = $1 if $str =~ /version (\d\.\d\.\d)/;
    $version;
}

# subroutines
sub err_exit {
    my $msg = $_[0];
    print STDERR "\e[31mError:\e[0m $msg\n";
    exit 1;
}

sub warn_msg {
    my $msg = $_[0];
    print STDERR "\e[35mWarning:\e[0m $msg\n";
}
